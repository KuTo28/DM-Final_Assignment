## Introduction

!TODO

## Helpers

```{r stats model helper}
model_statistics <- function(num_samples, target_variable, dataframe) {
  df2 <- dataframe

  # Sample non-NA indices
  non_na_indices <- which(!is.na(df2[[target_variable]]))
  sample_indices <- sample(non_na_indices, num_samples)

  df2[[target_variable]][sample_indices] <- NA

  # Build model
  model_formula <- formula(paste(target_variable, "~ ."))
  weight_model <- rpart(model_formula, data = df2, method = "anova")

  # Predict for NA values
  df2[[target_variable]][is.na(df2[[target_variable]])] <- predict(weight_model, newdata = df2[is.na(df2[[target_variable]]), ])

  # Actual values for comparison
  actual_values <- dataframe[[target_variable]][sample_indices]

  # Calculate accuracy and standard deviation
  accuracy <- 1 - sum((df2[[target_variable]][sample_indices] - actual_values)^2) / sum((actual_values - mean(actual_values))^2)
  std_deviation <- sd(df2[[target_variable]][sample_indices] - actual_values)

  # Return results
  return(tibble(accuracy = accuracy, std_deviation = std_deviation))
}
```

```{r plot pie helper}
plot_pie_freq <- function(variable, plot_name) {
  data <- data.frame(table(variable))

  color_palette <- pals::stepped3(n = length(unique(variable)))
  ggplot(data, aes(x = "", y = Freq, fill = variable)) +
    geom_bar(stat = "identity", width = 1) +
    geom_text(
      aes(x = 1.6, label = sprintf("%.1f%%", Freq / sum(Freq) * 100)),
      position = position_stack(vjust = 0.5),
      size = 4
    ) +
    coord_polar(theta = "y") +
    labs(title = plot_name) +
    scale_fill_manual(values = color_palette) +
    theme_void() +
    theme(
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      plot.title = element_text(hjust = 0.5)
    )
}
```

```{r hclust helper}
perform_hclust <- function(data, method, num_clusters) {
  hc <- hclust(dist(data), method = method)
  hc <- cutree(hc, k = num_clusters)
  return(list(
    method = method,
    num_clusters = num_clusters,
    silhouette = sum(data.frame(silhouette(hc, dist(data)))$sil_width)
  ))
}

plot_hclust <- function(data, method, num_clusters, plot_name) {
  hc <- as.dendrogram(hclust(dist(data), method = method))
  hc <- color_branches(hc, k = num_clusters)

  # Customize the ggplot dendrogram
  fviz_dend(
    hc,
    main = plot_name,
    show_labels = FALSE
  ) +
    theme( # nolint
      plot.title = element_text(size = 14, hjust = 0.5), # nolint
    )
}

make_hclust <- function(variable, plot_name) {
  parameters <- expand.grid(
    method = c(
      # "ward.D", "ward.D2",
      "single", "complete", "average", "mcquitty", "median", "centroid"
    )
  )

  hclust_metrics <- bind_rows(
    pmap(parameters, ~ perform_hclust(variable, ..1, num_clusters = 3))
  )

  (best_result <- hclust_metrics[which.max(hclust_metrics$silhouette), ])

  plot_hclust(variable, best_result$method, best_result$num_clusters, plot_name)
}
```

## Setup

```{r libraries, message=FALSE}
library(dplyr)
library(ggplot2)
library(here)
library(purrr)
library(rpart)
library(statebins)
library(tidygeocoder)
library(leaflet)
library(gridExtra)
library(GGally)
library(stringr)
library(pals)
library(cluster)
library(factoextra)
library(tidymodels)
library(caret)
library(glue)
library(dbscan) # Density based cluster
library(patchwork) # Plot composer
library(dendextend) # Color dedongram by cluster

set.seed(27)
```

```{r df load}
df <- read.csv(here("data", "heart_data.csv"))

df[df == ""] <- NA
df <- df |> mutate(across(where(is.character), as.factor))
```

```{r df summary}
str(df)
summary(df)
```

## Raw Data Analysis

### Non-numeric values

!TODO

```{r plot NA_col pie}
pie_data <- data.frame(
  category = c("NA", "Non-NA"),
  count = c(sum(is.na(df)), sum(!is.na(df)))
) |>
  mutate(
    percentage = round(count / sum(count) * 100, 2)
  )

color_palette <- pals::stepped3(n = length(unique(pie_data)))
ggplot(pie_data, aes(x = "", y = count, fill = category)) +
  geom_bar(stat = "identity", width = 1) +
  geom_text(
    aes(x = 1.6, label = sprintf("%.1f%%", count / sum(count) * 100)),
    position = position_stack(vjust = 0.5),
    size = 4
  ) +
  coord_polar(theta = "y") +
  labs(title = "NA vs Non-NA Counts") +
  scale_fill_manual(values = color_palette) +
  theme_void() +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    plot.title = element_text(hjust = 0.5)
  )
```

```{r plot NA_col}
na_df <- tibble(
  column = names(df),
  na_count = colSums(is.na(df))
) |>
  filter(na_count > 0) |>
  arrange(desc(na_count))

# Assuming na_df is your data frame
ggplot(
  na_df,
  aes(
    x = column,
    y = na_count,
    label = scales::percent(na_count / sum(na_count), accuracy = 0.01)
  )
) +
  geom_bar(
    stat = "identity",
    fill = "skyblue",
    position = "dodge"
  ) +
  geom_text(
    aes(label = scales::percent(na_count / sum(na_count), accuracy = 0.01)),
    position = position_dodge(width = 1), # Adjust width as needed
    vjust = 0.4, # Adjust vertical position of labels
    hjust = -0.3,
    size = 3 # Adjust text size
  ) +
  labs(title = "NA Counts for Each Column") +
  theme_minimal() +
  theme(
    axis.text.y = element_text(hjust = 1),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    plot.title = element_text(hjust = 0.5)
  ) +
  coord_flip()
```

```{r df NA_row}
na_group_threshold <- 5

na_count <- df |>
  is.na() |>
  rowSums() |>
  table() |>
  as.data.frame() |>
  mutate(across(is.factor, as.numeric)) |>
  rename(num_na = Var1) |>
  mutate(num_na = num_na - 1)

na_count_unbounded <- na_count

na_count <- na_count |>
  filter(num_na <= na_group_threshold) |>
  mutate(num_na = as.character(num_na)) |>
  bind_rows(
    data.frame(
      num_na = paste0(na_group_threshold, "+"),
      Freq = sum(na_count$Freq[as.numeric(na_count$num_na) > na_group_threshold])
    )
  )
```

```{r plot NA_row pie}
color_palette <- pals::stepped3(n = length(unique(na_count$num_na)))
ggplot(na_count, aes(x = "", y = Freq, fill = num_na, label = sprintf("%.1f%%", Freq / sum(Freq) * 100))) +
  geom_bar(stat = "identity", width = 1) +
  geom_text(
    aes(x = 1.6, label = sprintf("%.1f%%", Freq / sum(Freq) * 100)),
    position = position_stack(vjust = 0.5),
    size = 4
  ) + # Add labels
  coord_polar(theta = "y") +
  labs(title = "Distribution of NA Counts per Row") +
  scale_fill_manual(values = color_palette) + # Use the chosen color palette
  theme_void() +
  theme(
    axis.text.y = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    plot.title = element_text(hjust = 0.5)
  )
```

```{r plot NA_row bar}
ggplot(
  na_count_unbounded,
  aes(
    x = num_na,
    y = Freq,
    label = scales::percent(Freq / sum(Freq), accuracy = 0.0001)
  )
) +
  geom_bar(
    stat = "identity",
    fill = "skyblue",
    position = "dodge"
  ) +
  geom_text(
    aes(label = scales::percent(Freq / sum(Freq), accuracy = 0.0001)),
    position = position_dodge(width = 1), # Adjust width as needed
    vjust = 0.4, # Adjust vertical position of labels
    hjust = -0.3,
    size = 3 # Adjust text size
  ) +
  labs(title = "NA Distribution per Rows") +
  theme_minimal() +
  theme(
    axis.text.y = element_text(hjust = 1),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    plot.title = element_text(hjust = 0.5)
  ) +
  coord_flip() +
  scale_x_continuous(
    breaks = na_count_unbounded$num_na, # Set breaks based on your data
    labels = na_count_unbounded$num_na # Set labels based on your data
  )
```


```{r sandbox plot weight}
boxplot(na.omit(df$WeightInKilograms), main = "Weight")
```

```{r sandbox plot height}
boxplot(na.omit(df$HeightInMeters), main = "Height")
```

```{r sandbox plot bmi}
boxplot(na.omit(df$BMI), main = "BMI")
```

```{r sandbox plot sleep}
boxplot(na.omit(df$SleepHours), main = "Sleep")
```

```{r sandbox plot physical}
boxplot(na.omit(df$PhysicalHealthDays), main = "Physical Health Days")
```

```{r sandbox plot mental}
boxplot(na.omit(df$MentalHealthDays), main = "Mental Health Days")
```

## Data cleanup

### Removal of "corrupted" data

Observations that have more than **5** will be considered as _corrupted_ and thus removed from the dataset

```{r NA remove}
df <- df[rowSums(is.na(df)) <= 5, ]
```

### Predictive models

We'll be using the set of observations that have **no** missing values (accounting for 61% of the data)

```{r}
model_accuracy <- function(model, train, test, characteristic) {
  fitted_model <- model |>
    fit(as.formula(paste(characteristic, "~ .")), data = train) # nolint

  pred <- fitted_model |>
    predict(test) |>
    pull(.pred_class) # nolint

  results <- test |>
    mutate(predictions = pred) |>
    metrics(truth = !!as.name(characteristic), estimate = predictions) |> # nolint
    filter(.metric %in% c("accuracy", "kap")) |> # nolint
    pivot_wider(names_from = .metric, values_from = .estimate) |> # nolint
    select(accuracy, kap) # nolint

  return(list("model" = fitted_model, "metrics" = as.data.frame(results)))
}
```

```{r sandbox predictive_models}
non_na <- df[rowSums(is.na(df)) == 0, ]
na_rows <- df[rowSums(is.na(df)) > 0, ]
na_rows_mutable <- df[rowSums(is.na(df)) > 0, ]

split_ratio <- 0.8
data_split <- initial_split(non_na, prop = split_ratio)

bool_cols <- df %>%
  select(where(~ all(. %in% c("Yes", "No", NA)))) %>%
  colnames()

acc_threshold <- 0.8
model <- decision_tree(
  engine = "rpart",
  mode = "classification"
)

for (name in bool_cols) {
  model_output <- model_accuracy(
    model,
    training(data_split),
    testing(data_split),
    name
  )

  # Check if accuracy is below the threshold
  if (model_output$metrics$accuracy < acc_threshold) {
    cat("[IGNORE ]", name, "had a subpar accuracy of", model_output$metrics$accuracy, "\n")
    next
  }
  cat("[REPLACE]", name, "is a good candidate, having an accuracy of", model_output$metrics$accuracy, "\n")

  # Predict for the specified rows with missing values
  pred <- model_output$model |>
    predict(na_rows) |>
    pull(.pred_class)

  # Replace only the missing values in na_rows for the given column
  for (value in seq_along(na_rows_mutable[[name]])) {
    if (is.na(na_rows_mutable[[name]][value])) {
      na_rows_mutable[[name]][value] <- pred[value]
    }
  }
  # na_rows <- na_rows %>%
  # mutate(across(all_of(bool_cols), ~ ifelse(is.na(.), pred, .)))
}
```
```{r}
summary(na_rows_mutable)
summary(na_rows)
```

### Data generation

Now we can use all the data in the dataset to predict the height and the weight

```{r data_gen weight}
weight_model <- rpart(WeightInKilograms ~ ., data = df, method = "anova")
df$WeightInKilograms[is.na(df$WeightInKilograms)] <- predict(weight_model, newdata = df[is.na(df$WeightInKilograms), ])
model_statistics(num_samples = 10000, target_variable = "WeightInKilograms", dataframe = df)
```
```{r data_gen height}
height_model <- rpart(HeightInMeters ~ ., data = df, method = "anova")
df$HeightInMeters[is.na(df$HeightInMeters)] <- predict(height_model, newdata = df[is.na(df$HeightInMeters), ])
model_statistics(num_samples = 10000, target_variable = "HeightInMeters", dataframe = df)
```

After predicting the values the BMI that were NA can be calculated and the `WeightInKilograms` and `HeightInMeters` are redundant and can be removed.
```{r}
df$BMI <- df$WeightInKilograms / (df$HeightInMeters^2)

BMI_subset <- subset(df, select = c("State", "BMI", "HadHeartAttack"))
BMI_subset$HadHeartAttack <- ifelse(BMI_subset$HadHeartAttack == "Yes", 1, 0)
# DEBUG
df |>
  select(where(~ any(is.na(.)))) |>
  mutate(across(where(is.character), as.factor)) |>
  summary()

df <- df |> select(-WeightInKilograms, -HeightInMeters)
```

### Variable recodifications

#### Age

- very young [0,25)
- young [25,35)
- mature [35,50)
- senior [50,65)
- old [65,80)
- very old [80,inf)

```{r age_bin}
df <- df |>
  mutate(
    AgeCategory = case_when(
      AgeCategory %in% c("Age 18 to 24") ~ "very young",
      AgeCategory %in% c("Age 25 to 29", "Age 30 to 34") ~ "young",
      AgeCategory %in% c("Age 35 to 39", "Age 40 to 44", "Age 45 to 49") ~ "mature",
      AgeCategory %in% c("Age 50 to 54", "Age 55 to 59", "Age 60 to 64") ~ "senior",
      AgeCategory %in% c("Age 65 to 69", "Age 70 to 74", "Age 75 to 79") ~ "old",
      AgeCategory %in% c("Age 80 or older") ~ "very old",
      is.na(AgeCategory) ~ "not known",
      TRUE ~ AgeCategory
    )
  ) |>
  mutate(AgeCategory = factor(
    AgeCategory,
    levels = c("very young", "young", "mature", "senior", "old", "very old", "not known")
  ))

df |> count(AgeCategory)
```


```{r plot age_dist pie}
plot_pie_freq(df$AgeCategory, "Age distribution")
```

#### BMI

```{r BMI_bin}
bmi_categories <- c("Underweight", "Normal Weight", "Overweight", "Obese", "Extremely Obese")
bmi_ranges <- c(0, 18.5, 24.9, 29.9, 34.9, Inf)

df$BMI <- cut(
  df$BMI,
  breaks = bmi_ranges,
  labels = bmi_categories,
  include.lowest = TRUE
)
```

```{r BMI pie plot}
plot_pie_freq(df$BMI, "BMI distribution")
```

#### Tetanus

```{r tetanus_map}
df <- df |>
  mutate(
    TetanusVaccinated = ifelse(
      str_detect(TetanusLast10Tdap, "^Yes"),
      "Yes",
      "No"
    )
  )

df <- df |> select(-TetanusLast10Tdap)
```

```{r tetanus plot pie}
plot_pie_freq(df$TetanusVaccinated, "Tetanus distribution")
```

#### Smoker

```{r smoke_e_cig}
df <- df |>
  mutate(
    ECigaretteUsage = case_when(
      ECigaretteUsage == "Not at all (right now)" ~ "No",
      ECigaretteUsage == "Never used e-cigarettes in my entire life" ~ "No",
      ECigaretteUsage == "Use them every day" ~ "Yes",
      ECigaretteUsage == "Use them some days" ~ "Yes",
      is.na(ECigaretteUsage) ~ "not known",
      TRUE ~ ECigaretteUsage
    )
  )

df <- df |>
  mutate(
    SmokerStatus = case_when(
      SmokerStatus == "Never smoked" ~ "No",
      SmokerStatus == "Former smoker" ~ "Yes",
      SmokerStatus == "Current smoker - now smokes some days" ~ "Yes",
      SmokerStatus == "Current smoker - now smokes every day" ~ "Yes",
      is.na(SmokerStatus) ~ "not known",
      TRUE ~ SmokerStatus
    )
  )
```

```{r smoking_map}
df <- df |>
  mutate(
    HasSmoked = ifelse(
      SmokerStatus == "Yes" | ECigaretteUsage == "Yes",
      "Yes",
      "No"
    )
  )

df <- df |> select(-SmokerStatus, -ECigaretteUsage)
```

```{r smoked pie plot}
plot_pie_freq(df$HasSmoked, "HasSmoked distribution")
```

#### Race

```{r}
unique(df$RaceEthnicityCategory)
# This is a mess to clean up
```

#### Last check time

```{r last_check_time_map}
df <- df |>
  mutate(
    YearsSinceCheckup = case_when(
      LastCheckupTime == "Within past year (anytime less than 12 months ago)" ~ 1,
      LastCheckupTime == "Within past 2 years (1 year but less than 2 years ago)" ~ 2,
      LastCheckupTime == "Within past 5 years (2 years but less than 5 years ago)" ~ 5,
      LastCheckupTime == "5 or more years ago" ~ 6,
      is.na(LastCheckupTime) ~ 999,
      TRUE ~ 999
    )
  )

df <- df |> select(-LastCheckupTime)

df |> count(YearsSinceCheckup)
```

```{r years_since_checkuo pie plot}
plot_pie_freq(df$YearsSinceCheckup, "YearsSinceCheckup distribution")
```

#### Yes/No

```{r boolean_map}
bool_cols <- df |>
  select(where(~ any(. %in% c("Yes", "No")))) |>
  colnames()

for (col in bool_cols) {
  df[[col]] <- ifelse(df[[col]] == "No", 0, 1)
}
```

#### Difficulties

```{r}
corr_df <- na.omit(df)
ggcorr(
  corr_df %>% select(contains("Difficulty")),
  label = TRUE,
  label_round = 2,
  hjust = 0.75,
  angle = -45
)
```

!TO_FORMAL They are very correlated, so just summ them up to account for multiple difficulties at the same time

```{r}
df <- df %>%
  mutate(
    LifeDifficulties = rowSums(select(., contains("Difficulty"))),
    across(contains("Difficulty"), ~NULL)
  )
```

#### Sleep

```{r cat sleep}
df <- df %>%
  mutate(
    Sleep = case_when(
      SleepHours %in% 1:5 | SleepHours %in% 11:24 ~ "Not Appropriate",
      SleepHours %in% c(6, 10) ~ "Appropriate",
      SleepHours %in% 7:9 ~ "Optimal",
      TRUE ~ as.character(SleepHours)
    )
  )
```

```{r sleep plot pie}
plot_pie_freq(df$Sleep, "Sleep distribution")
```

#### Mental and Physical

```{r hclust mental}
set.seed(29)

make_hclust(
  data.frame(df$MentalHealthDays) |>
    na.omit() %>%
    sample_n(1200) |>
    scale(),
  "MentalHealthDays Clustering Dendrogram"
)
```

```{r hclust physical}
make_hclust(
  data.frame(df$PhysicalHealthDays) |>
    na.omit() %>%
    sample_n(1200) |>
    scale(),
  "PhysicalHealthDays Clustering Dendrogram"
)
```

### Outlier elimination

!TODO

```{r outliers}
z_score_mask <- function(vec) {
  z_values <- abs((vec - mean(vec)) / sd(vec))

  return(z_values > 3)
}

iqr_mask <- function(vec) {
  q1 <- quantile(vec, .25, na.rm = TRUE)
  q3 <- quantile(vec, .75, na.rm = TRUE)
  iqr <- IQR(vec, na.rm = TRUE)

  return(vec < (q1 - 1.5 * iqr) | vec > (q3 + 1.5 * iqr))
}
```

### Duplicated observations

Good practice to remove duplicated rows before oversampling ! DO IT AFTER APLYING FEATURE ENGINEERING AND WHATNOT

```{r distinct_removal}
cat("Removing", sum(duplicated(df)), "duplicated observations")
df <- unique(df)
```

## Data visualization

```{r}
ggcorr(
  df |> select(-where(is.factor)),
  label = TRUE,
  label_round = 2,
  hjust = 0.75,
  angle = -45
)
```

```{r states_map_final}
# geocoded_data <- tibble(State = unique(df$State)) |> geocode("State")
#
# obs_counts <- table(df$State)
# # Add the Obs column to the geocoded_data
# geocoded_data$Obs <- obs_counts[match(geocoded_data$State, names(obs_counts))]
#
# # Merge latitude and longitude information into your_data
# map <- leaflet(data = geocoded_data) |>
#   addTiles() |>
#   addMarkers(
#     lng = ~long,
#     lat = ~lat,
#     popup = ~ paste("Number of observations: ", Obs)
#   ) |>
#   addLegend("bottomright", colors = "blue", labels = "Data Points")
#
# # Display the map
# map
```

```{r BMI_heart_attack_state}
# Color to state the amount of heart attacks per state
# number to say the BMI Of the state

state_abbreviations <- c("DC", "GU", "PR", "VI")

str(BMI_subset)
BMI_state <- BMI_subset |>
  mutate(State = as.character(State)) |>
  group_by(State) |>
  summarize(
    mean_BMI = mean(BMI, na.rm = TRUE),
    HeartAttacks = sum(HadHeartAttack, na.rm = TRUE)
  ) |>
  arrange(State) |>
  mutate(StateAbb = state.abb[match(State, state.name)]) |>
  mutate(StateAbb = case_when(
    State == "District of Columbia" ~ "DC",
    State == "Guam" ~ "GU",
    State == "Puerto Rico" ~ "PR",
    State == "Virgin Islands" ~ "VI",
    TRUE ~ StateAbb
  ))

BMI_state$lab <- paste(BMI_state$StateAbb, round(BMI_state$mean_BMI, 2), sep = "\n")


BMI_state <- BMI_state |>
  filter(State != "Guam")

sb <- statebins(
  state_data = BMI_state,
  state_col = "State",
  value_col = "HeartAttacks"
) +
  labs(title = "Heart attack distribution and BMI mean per state") +
  theme_void() +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    axis.line = element_blank(),
    plot.title = element_text(hjust = 0.5),
    plot.background = element_blank(),
    strip.background = element_blank()
  )

# https://stackoverflow.com/questions/76574854/how-to-add-count-labels-to-statebin-map
sb <- ggplot_build(sb)
sb$data[[2]]$label <- BMI_state$lab[match(sb$data[[2]]$label, BMI_state$StateAbb)]
sb <- ggplot_gtable(sb)

plot(sb)
```

```{r states_map_presentation, warning=FALSE}
state_counts <- table(df$State)

# Merge the counts with the original data
df_with_counts <- merge(
  df,
  data.frame(
    State = names(state_counts),
    Count = as.numeric(state_counts)
  ),
  by = "State",
  all.x = TRUE
)

# Plot the choropleth map using statebins_continuous
statebins(
  state_data = df_with_counts |> mutate(State = as.character(State)),
  state_col = "State",
  value_col = "Count"
) +
  labs(title = "Number of Observations in Each State") +
  theme_minimal() +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    axis.line = element_blank(),
    plot.title = element_text(hjust = 0.5)
  )
```


```{r}
# numeric_cols <- sapply(df, is.numeric)
#
# # Create histograms for numeric columns on separate pages
# par(mfcol = c(1, 1)) # Reset layout to default
#
# for (col in names(df[, numeric_cols, drop = FALSE])) {
#   hist(df[[col]], main = col, xlab = col, col = "lightblue", border = "black")
# }
```

## Classifying

```{r}
set.seed(123)
df_encoded <- df %>%
  na.omit() %>%
  mutate(across(where(is.character), as.factor))

str(df)
str(df_encoded)
gender_colors <- c("Male" = "#27a7d8", "Female" = "#ff9a00")

# Scatter plot with clusters
ggplot(df_encoded, aes(x = as.factor(BMI), color = Gender)) +
  geom_jitter(aes(y = as.numeric(PhysicalHealthDays)), width = 0.1) +
  scale_color_manual(values = gender_colors) +
  labs(
    title = "BMI vs. PhysicalHealthDays",
    x = "BMI",
    y = "Day"
  ) +
  theme_minimal() +
  coord_flip()
```
